///////////////////////////////////// Proyecto de Procesadores Integrados /////////////////////////////////////////////////////////////////////
//////////////////// Control de Brazo robot // Mando ////////////// By Arturo//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Objetivo: Este programa sirve para controlar via BlueTooth el Brazo Robot
 * Funcionamiento: Primero nos encontraremos con un menu donde puedes pasar de un modo a otro moviendo el Joystick a la derecha e
 *    izquierda. Para seleccionnar el modo, lo buscamos en el menu y pulsamos el Joystick, hecho esto se iniciará el modo seleccionado.
 *    Subir y bajar el Joystick sirve para variar la posicion en algunos modos.
 *    Para salir de un modo, pulsar de nuevo el Joystick.
 * Modos:
 *    Posicion Inicial: coloca el brazo en la posicion de inicio. Tras terminar el movimiento se veulve a la seleccion de modos.
 *    Coger Caja: el brazo inicia una secuencia de movimientos que le permitiran coger una caja situada en frente suya. Tras terminar la secuencia
 *      se veulve a la seleccion de modos.
 *    Reposo: el brazo se coloca en una posicion de reposo. Una vez alcanzada esta posicion volverá a la posicion de inicio y a la seleccion de modo
 *      tras presionar el boton.
 *    Control Manual: Moviendo el joystick a derecha e izquierda podremos ir seleccionando la parte del brazo que deseamos mover y subiendo y bajando
 *      cambiaremos la posicion de la parte sobre la que estemos en tiempo real.
 *    Control Total: Este modo es similar al anterior, solo que el brazo se movera simultaneamente a la posicion indicada.
 *    Guardar Secuencia: Con este modo podemos estableces una secuencia de hasta 5 etapas y la velocidad a la que se alcanza cada etapa. Para ellos nos
 *      encontramos con un menu similar al de Control Manual, pero esta vez deberemos presionar el Joystick para pasar a la configuracion de la siguiente
 *      etapa. Si no se desea utilizar todas las etapas solo se ha de pulsar el Joystick hasta salir del modo. El brazo no se mueve durante este modo.
 *    Iniciar Secuencia: Al seleccionar este modo, el brazo ejecuta la secuancia guardada anteriormente.
 *  
 *  Conexiones:
 *              LCD_I2C                     Joystick                HC 06
 *                    SCL -> Pin A5               VRx -> Pin A1         TXD -> 2
 *                    SDA -> Pin A4               VRy -> Pin A0         RXD -> R -> 3
 *                                                SW  -> Pin 4
 */


#include <Wire.h>               //Biblioteca para I2C
#include <LiquidCrystal_I2C.h>  //Biblioteca para LCD con I2C
#include <SoftwareSerial.h>     //Conexión Serial para el Bluetooth

SoftwareSerial BTSerial(2, 3); // RX | TX

LiquidCrystal_I2C lcd(0x27, 16, 2); //Configuramos la LCD

#define ejeX A1
#define ejeY A0
#define boton 4

bool B; //Variable auxiliar para el boton
bool Ejecutando;  //Indica si se esta ejecutando algun modo
bool ControlTotal;  //Diferencia entre Control Total y Manual
bool Z; //Variable auxiliar para Reposo
bool salir; //Indica que se debe salir del modo en el que se encuentre

byte posicion[7]={90,160,180,90,30,180,90};//Posicion del brazo
byte posicionAux[7]={0,0,0,0,0,0,60};//Posicion del auxiliar
byte state; //Numero del modo en el que se encuentra
byte v;   //Variable auxiliar para Control y Guardar Secuencia
byte vv;  //Variable auxiliar para Guardar Secuencia


const char *Texto[7]={"Posicion Inicial","IniciarSecuencia","GuardarSecuencia","Control Total   ","Control Manual  ","Reposo          ","Coger Caja      "};  //Modos de funcionamiento
const char *Miembro[7]={"Base            ","Hombro          ","Codo            ","M. Giro         ","M. Subir Bajar  ","Pinza           ","Velocidad       "};
const char *MenuGuardar[6]={"Inicio: ","Etapa1: ","Etapa2: ","Etapa3: ","Etapa4: ","Final:  "};
const char *textoAux; //Puntero auxiliar
const char *textoAux2; //Puntero auxiliar

void setup() {
  pinMode(boton,INPUT_PULLUP);
  Serial.begin(9600);
  BTSerial.begin(9600); //Comenzamos la conexion BT a una velocidad de 9600 Baudios

  //Iniciamos la LCD
  lcd.begin();
  lcd.backlight();
  Conectar();
  Cargando();
  lcd.setCursor(0,0);
  lcd.print(Texto[0]);
  lcd.setCursor(0,1);
  lcd.print("                ");
}

void loop() {
//Menu
  if (!Ejecutando){
    MenuModo();
  }

//Posicion Inicial, Coger Caja o Iniciar Secuencia
  if (Ejecutando && (state<2 | state==6)){  
    BTSerial.write(state+200);
    while (!salir)  Cargando(); 
    byte vector[6]={90,140,170,130,40,180};
    if (state != 2) for (int i=0;i<6;i++) posicion[i]=vector[i];
    else for (int i=0;i<6;i++) posicion[i]=posicionAux[i];
    lcd.setCursor(0,1);
    lcd.print("             ");
    Iniciar();
    salir=false;
  }

//Reposo
  salir=false;
  if (Ejecutando && state==5){  
    BTSerial.write(state+200);
    while (!salir)  Cargando(); 
    lcd.setCursor(0,1);
    lcd.print("                ");
    while (Ejecutando) Reposo(); //Se ejecuta el ControlTotal hasta que se pulse el Joystick
    salir=false;
    byte vector[6]={180,180,180,180,180,180}; //Vector al que quieres que vuelva
    for (int i=0;i<6;i++) posicion[i]=vector[i];
    //Mientras vuelve a su posicion:
    lcd.setCursor(0,0);
    lcd.print("Despertando     ");
    lcd.setCursor(0,1);
    lcd.print("Buenos Dias  :D ");
    while (!salir)  if (BTSerial.available()) salir=BTSerial.read();  //Espera a recibir que está en la posicion
    salir=false;
    Iniciar();
  }

//Control Manual
  if (Ejecutando && state==4){  
    BTSerial.write(state+200);
    //Imprime el menu de ControlManual
    lcd.setCursor(0,0);
    lcd.print(Miembro[v]);
    while (Ejecutando) Control(); //Se ejecuta el ControlManual hasta que se pulse el Joystick
  }
  
//Control Total
  if (Ejecutando && state==3){  
    BTSerial.write(state+200);
    while (Ejecutando) {ControlTotal=1; Control();} //Se ejecuta el ControlTotal hasta que se pulse el Joystick
    for (int i=0; i<6; i++) posicion[i]=posicion[6];  //Guarda la posicion actual en posicion
  }

//Guardar secuencia
  if (Ejecutando && state==2){  
    BTSerial.write(state+200);
    //Imprime el menu de ControlManual
    lcd.setCursor(0,0);
    lcd.print(Miembro[v]);
    lcd.setCursor(0,1);
    lcd.print(MenuGuardar[vv]);
    for (int i=0; i<6;i++) posicionAux[i]=posicion[i];
    while (Ejecutando) Guardar(); //Se ejecuta el ControlManual hasta que se pulse el Joystick
  }
}

 void MenuModo(){ //escribe en la LCD el Modo en el que se encuentra
  if (!digitalRead(boton)) B=1;
  if (B==1 && digitalRead(boton) && !Ejecutando) {
    Ejecutando=1;
    B=0;
  }
  
  if(analogRead(ejeX)<=124){  //Cuando mueves el Joystick a la derecha se mueve a un estado anterior
    textoAux2=Texto[state];
    if (state--==0) state=sizeof(Texto)/2-1;  //Si state es 0, se pone en el valor máximo del vector Modo, sino, reduce su valor
    textoAux=Texto[state];              //Guarda el texto del modo en el que esta para editarlo
    //Mueve el texto hacia la derecha
    for (int i=0;i<=16;i++){
      lcd.setCursor(i,0);
      lcd.print(textoAux2);
      lcd.setCursor(i-1,0);
      lcd.print(textoAux[i-1]);
      delay(10);
     }
  }
  
  if(analogRead(ejeX)>=900){  //Cuando mueves el Joystick a la izquierda se mueve a un estado posterior
    if (++state==(sizeof(Texto)/2)) state=0;  //Si state es el maximo, le da valor 0, sino, reduce aumenta su valor
    //Mueve el texto hacia la izquierda
    for (int i=16;i>=0;i--){
      lcd.setCursor(i,0);
      lcd.print(Texto[state]);
      delay(10);
    }
  }
 }
 
 void Control(){
  if(!ControlTotal){ //Control Manual
    if(analogRead(ejeX)<124){  //Cuando mueves el Joystick a la derecha se mueve a un estado anterior
      if (v--==0) v=5;
    lcd.setCursor(0,0);
    lcd.print(Miembro[v]);
    BTSerial.write(v+181);
    while (analogRead(ejeX)<=124) {}
    }
  
    if(analogRead(ejeX)>=900){ //Cuando mueves el Joystick a la derecha se mueve a un estado anterior
        if (++v==6) v=0;
      lcd.setCursor(0,0);
      lcd.print(Miembro[v]);
      BTSerial.write(v+181);
      while (analogRead(ejeX)>=900) {}
      }
  }
  if (ControlTotal) v=6;  //Control Total
  char ss[20];
  //Aumenta o Disminuye la posicion
  lcd.setCursor(0,1);
  lcd.print("Posicion: ");
  sprintf(ss,"%03i",posicion[v]);  //Pasamos la distancia a 3 digitos fijos
  lcd.print(ss);
  while(analogRead(ejeY)>=570 && posicion[v]<180) AumentarY(posicion,10);
  while(analogRead(ejeY)<=462 && posicion[v]>0) DisminuirY(posicion,10);

  //Sale de ControlManual
  if (!digitalRead(boton)) B=1;
  if (B==1 && digitalRead(boton)){
    ControlTotal=0;
    v=0;
    Iniciar();
    BTSerial.write(255); //Para que salga al menu el otro arduino
  }
}

 void Reposo(){
  unsigned long tiempo;
  //Escribe ZzZzZzZzZ
  lcd.setCursor(0,1);
  for (int i=0;i<16;i++){
    if (Z) lcd.print("Z");
    else lcd.print("z");
    tiempo=millis();

    //Está atento al boton
    while(millis()<tiempo+1000 ){
      if (!digitalRead(boton)) B=1;
      if (B==1 && digitalRead(boton)){
        break;
      }
    }
    if (B==1 && digitalRead(boton)){
      BTSerial.write(255);
      salir=false;
      Iniciar();
      break;
    }
    
    Z=!Z;
  }
  Z=!Z;
 }

 void Guardar(){
   if(analogRead(ejeX)>=900){  //Cuando mueves el Joystick a la derecha se mueve a un estado anterior
     if (v--==0) v=6;
     if (vv==0 && v==6) v=5;
     lcd.setCursor(0,0);
     lcd.print(Miembro[v]);
     while (analogRead(ejeX)>=900) {}
   }
   if(analogRead(ejeX)<=124){ //Cuando mueves el Joystick a la derecha se mueve a un estado anterior
      if (++v==7) v=0;
      if (vv==0 && v>=6) v=0;
      lcd.setCursor(0,0);
      lcd.print(Miembro[v]);
      while (analogRead(ejeX)<=124) {}
    }
    
    //Si se pulsa el boton pasa de etapa envia la etapa que acaba de configurar
    if (!digitalRead(boton)) B=1;
    if (B==1 && digitalRead(boton)){
        vv++;
        for (int i=0;i<7;i++){
          BTSerial.write(posicionAux[i]);
          delay(1);
        }
        lcd.setCursor(0,1);
        lcd.print(MenuGuardar[vv]);
        B=0;
    }
    
    char ss[20];
    //Aumenta o Disminuye la posicion
    lcd.setCursor(8,1);
    sprintf(ss,"%03i",posicionAux[v]);  //Pasamos la distancia a 3 digitos fijos
    lcd.print(ss);
    if (v==6) { //Si es la velocidad el rango de valores es entre 10 y 100
      lcd.print("%");
      while(analogRead(ejeY)>=570 && posicionAux[v]<100) AumentarY(posicionAux, 8);
      while(analogRead(ejeY)<=462 && posicionAux[v]>10) DisminuirY(posicionAux, 8);
    }
    else {
      lcd.print(" ");
      while(analogRead(ejeY)>=570 && posicionAux[v]<180) AumentarY(posicionAux, 8);
      while(analogRead(ejeY)<=462 && posicionAux[v]>0) DisminuirY(posicionAux, 8);
    }
    

    //Sale de GuardarSecuencia
    if (!digitalRead(boton) && vv>=5) B=1;
    if (B==1 && digitalRead(boton) && vv>=5){
      for (int i=0;i<7;i++){
          BTSerial.write(posicionAux[i]);
          delay(1);
      }
      ControlTotal=0;
      v=0;
      vv=0;
      Iniciar();
  }
 }

 void Conectar(){ //Comprueba si estan conectados los modulos BT
  unsigned long tiempo;
  
  lcd.setCursor(0,0);
  lcd.print("Por favor espere");
  lcd.setCursor(0,1);
  lcd.print("Conectando");
  
//Para comprobar si esta concetado manda un 1 cada medio segundo, el otro modulo al recibirlo debe
//mandar otro 1 como respuesta, al recibir el 1 del otro modulo sabemos que estan concetados
  while(!salir) {
    lcd.setCursor(10,1);
    for (int i=0; i<4; i++){
      BTSerial.write(1);  //manda el 1
      tiempo=millis();
      while (millis()<= tiempo+500) if (BTSerial.available())salir=BTSerial.read(); //Comprueba si lo recibe
      if (salir) break; //Si lo recibe sale del For
      lcd.print(".");
    }
    lcd.setCursor(10,1);
    lcd.print("    ");
  }
  salir=false;
 }

 void Iniciar(){ //Puente entre un modo y el menu inicial
    lcd.setCursor(0,0);
    lcd.print(Texto[state]);
    lcd.setCursor(0,1);
    lcd.print("                ");
    B=0;
    Ejecutando=0;

 }

 void Cargando(){ //Puente entre el menu y un modo
   unsigned long tiempo;
   lcd.setCursor(0,1);
   lcd.print("Ejecutando    ");
   lcd.setCursor(10,1);
    for (byte i=0;i<4;i++){
      tiempo=millis();
      while(millis()<tiempo+400)
        if (BTSerial.available()) salir=BTSerial.read();
      lcd.print(".");
   }
 }

 void AumentarY(byte vector[],byte A){  //Aumenta la posicion al levantar el eje Y
  char ss[20];
  int Aux=map(analogRead(ejeY),1023,512,1,8);
  vector[v]++;
  if (state!=2) BTSerial.write(vector[v]);  //Si no se encuentra en el estado de Guardar, envia el numero
  lcd.setCursor(A,1);
  sprintf(ss,"%03i",vector[v]);  //Pasamos la distancia a 3 digitos fijos
  lcd.print(ss);
  if (state==2 && v==6) lcd.print("%"); //Si se encuentra en el estado de guardar, en el factor de la velocidad
  else lcd.print(" ");
  delay(exp(Aux));
 }

  void DisminuirY(byte vector[], byte A){  ////Disminuye la posicion al levantar el eje Y
  char ss[20];
  int Aux=map(analogRead(ejeY),0,512,1,8);
  vector[v]--;
  if (state!=2) BTSerial.write(vector[v]);
  lcd.setCursor(A,1);
  sprintf(ss,"%03i",vector[v]);  //Pasamos la distancia a 3 digitos fijos
  lcd.print(ss);
  if (state==2 && v==6) lcd.print("%");
  else lcd.print(" ");
  delay(exp(Aux));
 }
