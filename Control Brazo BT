///////////////////////////////// Proyecto Procesadores Integrados /////////////////////////////////////////////////////////////////////////////
//////////////////// Control de Brazo robot // Brazo ////////////// By Arturo//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Objetivo: Este programa sirve para mover el Brazo Robot
 * Funcionamiento: Siguiendo las intrucciones del programa del mando, este programa recibira la informacion
 * necesaria para efectuar de manera precisa el movimiento del brazo y sus distintas funciones.
 *  
 *  Conexiones:
 *              Servos                        HC 05
 *                    Base        -> 3          TXD -> 2
 *                    Hombro      -> 5          RXD -> R -> 4
 *                    Codo        -> 6
 *                    Mu単eca Giro -> 9
 *                    Mu単eca S B  -> 10
 *                    Pinza       -> 11
 */
 
#include <SoftwareSerial.h>  //Biblioteca para BT
#include <Servo.h>           //Biblioteca para Servos

SoftwareSerial BTSerial(2, 4); // RX | TX

Servo SBase;    //Servomotor de la base
Servo SHombro;  //Servomotor del hombro
Servo SCodo;    //Servomotor del codo
Servo SMGiro;   //Servomotor de la mu単eca para giro
Servo SMSB;     //Servomotor de la mu単eca para subir y bajar
Servo SPinza;   //Servomotor de la pinza

bool salir;  //Condicion de salida de un modo

byte velNominal=4;  //Velocidad de las acciones
byte posicion[7]={0,10,120,10,60,4,0}; //Posicion del brazo
byte posicionGuardar[6][7]={{0,0,0,0,0,0,60},
                            {0,0,0,0,0,0,0},
                            {0,0,0,0,0,0,0},
                            {0,0,0,0,0,0,0},
                            {0,0,0,0,0,0,0},
                            {0,0,0,0,0,0,0}};//Posicion guardada
 
int state;   //Donde se guarda lo que se recibe por BT


void setup() 
{
  //Configuramos los servos
  SBase.attach(3);
  SHombro.attach(5);
  SCodo.attach(6);
  SMGiro.attach(9);
  SMSB.attach(10);
  SPinza.attach(11);

  SBase.write(0);
  
  BTSerial.begin(9600);  //Comenzamos la conexion BT a una velocidad de 9600 Baudios
  Serial.begin(9600);
  Serial.println("Iniciado");
  
}
 
void loop()
{
  
  if (BTSerial.available()){  //Cuando reciba un numero:
    state=BTSerial.read();    //Guarda el numero recibido
    salir=false;
    
    switch (state-200){       //Se le resta 200 ya que los numeros de los modos se envian a partir del 200
      case 0: PosicionInicial();  break;  //Se ejecuta el modo de Posicion Inicial
      case 1: IniciarSecuencia(); break;  //Se ejecuta el modo de Iniciar Secuencia
      case 2: GuardarSecuencia(); break;  //Se ejecuta el modo de Guardar Secuencia
      case 3: ControlTotal();     break;  //Se ejecuta el modo de Control Total
      case 4: ControlManual();    break;  //Se ejecuta el modo de Control Manual
      case 5: Reposo();           break;  //Se ejecuta el modo de Reposo 
      case 6: CogerCaja();        break;  //Se ejecuta el modo de Coger Caja
    }
  }
}

void PosicionInicial(){
  byte vector[6]={180,180,180,180,180,180};
  Serial.println("Posicion Inicial");
 
  moverServos(vector,velNominal);
  
  BTSerial.write(1);  //Comunica que ha terminado
}

void CogerCaja(){
  byte vector0[6]={180,180,180,180,180,180}; //Echarse para alante
  byte vector1[6]={0,0,180,10,70,90};   //Coger
  Serial.println("Coger Caja");
  moverServos(vector0,velNominal);
  moverServos(vector1,velNominal);
  PosicionInicial();
}

void Reposo(){
  byte vector0[6]={0,0,0,0,0,0};
  byte vector1[6]={180,180,180,180,180,180};
  Serial.println("Reposo");
  moverServos(vector0,velNominal);
  BTSerial.write(1);  //Comunica que ha terminado
  while (!salir)  //Mientras que no reciba que se ha pulsado el boton, se queda aqui
    if (BTSerial.available()) salir=BTSerial.read();
  moverServos(vector1,velNominal);
  BTSerial.write(1);
}

void ControlManual(){
  byte v=0; //Indice del servo que se esta utilizando
  Serial.println("Control Manual");
  while (!salir){   //Mientras que no reciba que se ha pulsado el boton, se queda aqui
     if (BTSerial.available()){
        state=BTSerial.read();
       if (state<=180){   //Si el numero que recibe es menor de 180 es una posicion
        posicion[v]=state;
        switch (v){   //Escribe en el servo correcto
          case 0: SBase.write(posicion[v]);  break;
          case 1: SHombro.write(posicion[v]);  break;
          case 2: SCodo.write(posicion[v]);  break;
          case 3: SMGiro.write(posicion[v]); break;
          case 4: SMSB.write(posicion[v]); break;
          case 5:  SPinza.write(posicion[v]);  break;
       }
        
       }
       else if (state==255) salir=true;   //Si el numero que recibe es 255 sale de la funcion
       else v=state-181;  //Sino el numero se refiere al servo a utilizar
     }
  }
}

void ControlTotal(){
  Serial.println("Control Total");
  //Movemos el brazo hasta la posicion que indique el control total
  byte vector[6];
  for (int i=0;i<6;i++) vector[i]=posicion[6];
  moverServos(vector,velNominal);
  while (!salir){   //Mientras que no reciba que se ha pulsado el boton, se queda aqui
      if (BTSerial.available()){
        state=BTSerial.read();

        if (state<=180){  //Si el numero que recibe es menor de 180 es una posicion
        posicion[6]=state;
        SBase.write(posicion[6]);
        SHombro.write(posicion[6]);
        SCodo.write(posicion[6]);
        SMGiro.write(posicion[6]);
        SMSB.write(posicion[6]);
        SPinza.write(posicion[6]);
        }
        else salir=true;  //Si el numero que recibe es mayor de 180 sale de la funcion
      }
  }
  for (int i=0;i<6;i++) posicion[i]=posicion[6];  //indicamos la posicion en la que se encuentra el brazo
}
  
void GuardarSecuencia(){
  byte Estado=0;
  byte Miembro=0;
  Serial.println("Guardar Secuencia");
  while (Estado<6){
    if (BTSerial.available()){  //Cuando reciba un numero:
      state=BTSerial.read();    //Guarda el numero recibido
      posicionGuardar[Estado][Miembro]=state;
      if (++Miembro==7){  //Cada vez que recibe un numero mueve una posicion de la matriz
        Miembro=0;
        Estado++;
      }
    }
  }
}

void IniciarSecuencia(){
  byte vector[6];
  byte velocidad;
  Serial.println("Iniciar Secuencia");
  for (int k=1;k<6;k++){
    for (int j=0;j<6;j++) vector[j]=posicionGuardar[k][j];
    velocidad=map(posicionGuardar[k][6],10,100,50,3);
    Serial.println(velocidad);
    moverServos(vector,velocidad);
  }
  BTSerial.write(1);
  for (int j=0;j<6;j++) posicion[j]=vector[j];
}

void moverServos(byte hasta[],byte vel){
  while(!compararArray(posicion, hasta)){
    for (int i=0; i<6;i++){
      if (posicion[i]!=hasta[i]){
        if (posicion[i]-hasta[i]<0)  posicion[i]++;
        if (posicion[i]-hasta[i]>0)  posicion[i]--;
        switch (i){
          case 0: SBase.write(posicion[i]);  break;
          case 1: SHombro.write(posicion[i]);  break;
          case 2: SCodo.write(posicion[i]);  break;
          case 3: SMGiro.write(posicion[i]); break;
          case 4: SMSB.write(posicion[i]); break;
          case 5: SPinza.write(posicion[i]);  break;
        }
      }
      delay(vel);
   }
 }
} 

boolean compararArray(byte array1[],byte array2[])
{
 for (int j=0;j<6;j++)
    if(array1[j] != array2[j])return(false);
 return(true);
}
